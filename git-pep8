#!/usr/bin/env python
from __future__ import print_function

import sys
import os
import os.path
from subprocess import Popen, PIPE, STDOUT
from hashlib import sha1


BUFSIZE = 16 * 1024 * 1024

ERRORS = [
    ("W391", "blank line at end of file"),
    ("W291", "trailing whitespace"),
    ("W293", "blank line contains whitespace"),
    ("W191", "indentation contains tabs"),
    ("E101", "indentation contains mixed spaces and tabs"),
    ("E301", "expected 1 blank line, found 0"),
    ("E302", "line spacing between functions and classes"),
    ("E303", "linespacing between functions and classes"),
    ("E221", "multiple spaces before operator"),
    ("E222", "multiple spaces after operator"),
    ("E261", "whitespace after inline comment"),
    ("E226", "missing whitespace around arithmetic operator"),
    ("E225", "space around operator"),
    ("E231", "missing whitespace after ','"),
    ("E203", "whitespace before colon"),
    ("E201", "whitespace around [ and ]"),
    ("E202", "whitespace around [ and ]"),
    ("E251", "unexpected whitespace around parameter equals"),
    ("E711", "comparison to None should be 'if cond is None:'"),
    ("E712", "comparison to True should be 'if cond is True:' or 'if cond:'"),
    ("E701", "multiple statements on one line (colon)"),
    ("E401", "multiple imports on one line"),
    ("E502", "the backslash is redundant between brackets"),

    #("E123", "closing bracket does not match indentation of opening bracket's line"),
    #("E124", "closing bracket does not match visual indentation")
    #("E125", "continuation line does not distinguish itself from next logical line"),
    #("E126", "continuation line over-indented for hanging indent"),
    #("E127", "continuation line over-indented for visual indent"),
    #("E128", "continuation line under-indented for visual indent"),
]


def message(msg):
    print(msg, file=sys.stderr)


def sha1_file(filename):
    with open(filename) as f:
        return sha1(f.read()).hexdigest()


def run_git(fullpath, comment, dryrun, author=None):
    cmd = ["git", "commit", fullpath, "-m", "{0}: {1}".format(fullpath, comment)]
    if author:
        cmd += ["--author", author]

    if dryrun:
        message(" ".join(cmd))
    else:
        p = Popen(cmd, stdout=PIPE, stderr=PIPE, bufsize=BUFSIZE)
        _, errors = p.communicate()
        if p.returncode:
            raise Exception(errors)


def get_filelist(start_dir, recurse, ext):
    if recurse:
        file_list = [
            os.path.join(root, f)
            for root, _, files in os.walk(start_dir)
            for f in files
        ]
    else:
        file_list = os.listdir(start_dir)
    return [path for path in file_list if os.path.splitext(path)[1] == ext]


def loop_params(file_list):
    for error_no, error_comment in ERRORS:
        message("{0} {1}".format(error_no, error_comment))
        for fullpath in file_list:
            hash_before = sha1_file(fullpath)
            yield (fullpath, hash_before, error_no, error_comment)


def run_autopep8(start_dir=".", ext=".py", recurse=True, dryrun=False, verbose=False, autopep8=None, author=None):
    file_list = get_filelist(start_dir, recurse, ext)
    i = 0
    for fullpath, hash_before, error_no, error_comment in loop_params(file_list):
        cmd = [autopep8, "--in-place", "--verbose", "--select={0}".format(error_no), fullpath]
        if verbose:
            message(" ".join(cmd))
        p = Popen(cmd, stdout=PIPE, stderr=STDOUT, bufsize=BUFSIZE)
        output, errors = p.communicate()
        if p.returncode:
            raise Exception(errors)
        elif hash_before != sha1_file(fullpath):
            # I can't tell if autopep8 has modified a file from the return code,
            # so I do it the hard way...
            message(output)
            run_git(fullpath, error_comment, dryrun)
            i += 1
    print("# {0} files scanned/modified".format(i), file=sys.stderr)


def option_parser():
    from optparse import OptionParser, make_option
    option_list = [
        make_option('-r', '--recurse', dest='recurse', action='store_true', default=False),
        make_option('-e', '--ext', dest='extensions', action='store', default=".py"),
        make_option('-d', '--dryrun', dest='dryrun', action='store_true', default=False),
        make_option('-s', '--startdir', dest='startdir', action='store', default="."),
        make_option('-v', '--verbose', dest='verbose', action='store_true', default=False),
        make_option('-a', '--autopep8', dest='autopep8', action='store', default="autopep8"),
        make_option('-u', '--author', dest='author', action='store'),
    ]
    return OptionParser(option_list=option_list)


def binary_in_path(binary):
    return any(os.path.exists(os.path.join(path, binary)) for path in set(os.environ["PATH"].split(':')))


def test_for_required_binaries(needed_binaries):
    found = [(binary, binary_in_path(binary)) for binary in needed_binaries]
    if not all(found_binary for _, found_binary in found):
        message("Certain additional binaries are required to run:")
        for binary, found_binary in found:
            message("\t{0}: {1}".format(binary, "Found" if found_binary else "Not found"))
        sys.exit(1)


def main():
    # Parse Command line options
    parser = option_parser()
    (o, _) = parser.parse_args()

    # Test for needed binaries. Exit if missing.
    needed_binaries = [
        "git",
        o.autopep8,
        "pep8"
    ]
    test_for_required_binaries(needed_binaries)

    # Do the business
    run_autopep8(
        start_dir=o.startdir, ext=o.extensions, recurse=o.recurse,
        dryrun=o.dryrun, verbose=o.verbose,
        autopep8=o.autopep8,
        author=o.author
    )


if __name__ == '__main__':
    main()
